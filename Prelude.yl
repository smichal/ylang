
ifte True  then _ = then;
ifte False _ else = else;

and True x = x;
and _ _ = False;

or False x = x;
or _ _ = True;

`&& = and;
`|| = or;

not True = False;
not False = True;

`$ f arg = f arg;
--`$! f arg = case arg of arg -> f arg;;

head [x & xs] = x;
tail [x & xs] = xs;

map f [] = [];
map f [x & xs] = (f x) : (map f xs);


inc x = x + 1;
ones = 1 : ones;
naturals = 1 : map inc naturals;

fix f = f (fix f);

fib 0 = 0;
fib 1 = 1;
fib n = (fib (n - 1)) + (fib (n - 2));

tst x = case x of
  1 -> 2;
  2 -> 5;
  [1 x] -> 42;
  x -> x + 1;;


`++ []       ys = ys;
`++ [x & xs] ys = x : xs ++ ys;

nth [x & xs] 0 = x;
nth [x & xs] n = nth xs (n - 1);

`!! = nth;

take 0 _  = [];
take _ [] = [];
take n [x & xs] =  x : take (n - 1) xs;

reverse list = let
    rev [] a = a;
    rev [x & xs] a = rev xs (x : a);
  in
    rev list [];

-- show1 prefix Nil = prefix;
-- show1 prefix [a & as] = show1 (a :! prefix) as;
-- show list = show1 Nil (reverse list);
show [] = [];
show [x & xs] = x :! (show xs);
show x = x;

testLetIn = let a = 1; b = 2 in a + b == 3;

testLetIn2 = let
    f x = x + 1
  in
    (f 41) == 42;

loop = loop + 1;



fix-fact = fix (\rec -> \n -> ifte (n == 0) 1 (n * (rec (n - 1))));


ff n = let
  f 0 = 1;
  f n = n * (f (n - 1)) in f n;

t1 list = let
  r [] = 0;
  r [x & xs] = (r xs) + 1
  in r list;


`>= x y = not (x < y);

filter p [] = [];
filter p [x & xs] = ifte (p x) (x : filter p xs) (filter p xs);

qsort [] = [];
qsort [x & xs] = qsort (filter (`>= x) xs) ++ [x] ++ qsort (filter (`< x) xs);


`>>= = bind;
bind [Just x] f = f x;
bind [Nothing] _ = Nothing;






